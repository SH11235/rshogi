//! Integration tests for MovePicker with enhanced search

#[cfg(test)]
mod tests {
    use crate::ai::board::{Color, PieceType, Position, Square};
    use crate::ai::evaluate::MaterialEvaluator;
    use crate::ai::history::History;
    use crate::ai::move_picker::MovePicker;
    use crate::ai::movegen::MoveGen;
    use crate::ai::moves::{Move, MoveList};
    use crate::ai::search_enhanced::{EnhancedSearcher, SearchStack};
    use crate::ai::usi::parse_usi_square;
    use std::collections::HashSet;
    use std::sync::Arc;
    use std::time::Duration;

    #[test]
    fn test_move_picker_generates_all_moves() {
        let pos = Position::startpos();
        let history = Arc::new(History::new());
        let stack = SearchStack::default();
        let mut picker = MovePicker::new(&pos, None, None, &history, &stack, 1);

        // Collect all moves from picker
        let mut picker_moves = HashSet::new();
        while let Some(mv) = picker.next_move() {
            assert!(picker_moves.insert(mv), "Duplicate move generated");
        }

        // Generate all moves directly
        let mut move_list = MoveList::new();
        let mut gen = MoveGen::new();
        gen.generate_all(&pos, &mut move_list);

        // Verify all moves are generated
        assert_eq!(
            picker_moves.len(),
            move_list.len(),
            "MovePicker should generate all legal moves"
        );

        for &mv in move_list.as_slice() {
            assert!(picker_moves.contains(&mv), "Move {mv:?} not generated by picker");
        }
    }

    #[test]
    fn test_move_picker_tt_move_first() {
        let pos = Position::startpos();
        let history = Arc::new(History::new());
        let stack = SearchStack::default();

        // Set a specific move as TT move (2g2f)
        let tt_move = Some(Move::normal(
            parse_usi_square("2g").unwrap(),
            parse_usi_square("2f").unwrap(),
            false,
        ));
        let mut picker = MovePicker::new(&pos, tt_move, None, &history, &stack, 1);

        // First move should be TT move
        assert_eq!(picker.next_move(), tt_move);
    }

    #[test]
    fn test_move_picker_respects_killers() {
        let pos = Position::startpos();
        let history = Arc::new(History::new());
        let mut stack = SearchStack::default();

        // Set killer moves (legal pawn moves)
        // Note: In this implementation, these correspond to 7g7f and 6g6f
        stack.killers[0] = Some(Move::normal(
            parse_usi_square("7g").unwrap(),
            parse_usi_square("7f").unwrap(),
            false,
        ));
        stack.killers[1] = Some(Move::normal(
            parse_usi_square("6g").unwrap(),
            parse_usi_square("6f").unwrap(),
            false,
        ));

        let mut picker = MovePicker::new(&pos, None, None, &history, &stack, 1);

        // Collect early moves
        let mut early_moves = Vec::new();
        for _ in 0..10 {
            if let Some(mv) = picker.next_move() {
                early_moves.push(mv);
            }
        }

        // Killers should appear early (after captures)
        let killer_positions: Vec<_> = early_moves
            .iter()
            .enumerate()
            .filter(|(_, &mv)| stack.killers.contains(&Some(mv)))
            .map(|(i, _)| i)
            .collect();

        assert!(!killer_positions.is_empty(), "Killer moves should be generated");

        // Killers should be relatively early in the order
        for &pos in &killer_positions {
            assert!(pos < 20, "Killer move at position {pos} is too late");
        }
    }

    #[test]
    fn test_enhanced_search_with_move_picker() {
        let evaluator = Arc::new(MaterialEvaluator);
        let mut searcher = EnhancedSearcher::new(16, evaluator);
        let mut pos = Position::startpos();

        // Search to depth 6
        let (best_move, score) = searcher.search(&mut pos, 6, None, Some(100_000));

        assert!(best_move.is_some());
        assert!(score.abs() < 200); // Should be relatively balanced
    }

    #[test]
    fn test_move_picker_capture_ordering() {
        // Create a position with captures available
        let mut pos = Position::startpos();

        // Make some moves to create a position with captures
        // These moves create a position where captures are possible
        let moves = [
            Move::normal(
                parse_usi_square("7g").unwrap(),
                parse_usi_square("7f").unwrap(),
                false,
            ), // 7g7f
            Move::normal(
                parse_usi_square("7c").unwrap(),
                parse_usi_square("7d").unwrap(),
                false,
            ), // 7c7d
            Move::normal(
                parse_usi_square("7f").unwrap(),
                parse_usi_square("7e").unwrap(),
                false,
            ), // 7f7e
            Move::normal(
                parse_usi_square("6c").unwrap(),
                parse_usi_square("6d").unwrap(),
                false,
            ), // 6c6d
            Move::normal(
                parse_usi_square("7e").unwrap(),
                parse_usi_square("7d").unwrap(),
                false,
            ), // 7e7d (capture)
        ];

        for mv in &moves {
            pos.do_move(*mv);
        }

        let history = Arc::new(History::new());
        let stack = SearchStack::default();
        let mut picker = MovePicker::new(&pos, None, None, &history, &stack, 1);

        // Get first few moves
        let mut first_moves = Vec::new();
        for _ in 0..5 {
            if let Some(mv) = picker.next_move() {
                first_moves.push(mv);
            }
        }

        // Check if any captures are prioritized
        let captures: Vec<_> = first_moves
            .iter()
            .filter(|&&mv| !mv.is_drop() && pos.board.piece_on(mv.to()).is_some())
            .collect();

        if !captures.is_empty() {
            // Captures should appear early
            let first_capture_idx = first_moves
                .iter()
                .position(|&mv| !mv.is_drop() && pos.board.piece_on(mv.to()).is_some())
                .unwrap();

            assert!(
                first_capture_idx < 3,
                "First capture at position {first_capture_idx} is too late"
            );
        }
    }

    #[test]
    fn test_quiescence_move_picker() {
        // Create a position with captures
        let mut pos = Position::startpos();

        // Make moves to create capture opportunities
        let moves = [
            Move::normal(
                parse_usi_square("2g").unwrap(),
                parse_usi_square("2f").unwrap(),
                false,
            ), // 2g2f
            Move::normal(
                parse_usi_square("6c").unwrap(),
                parse_usi_square("6d").unwrap(),
                false,
            ), // 6c6d
            Move::normal(
                parse_usi_square("2f").unwrap(),
                parse_usi_square("2e").unwrap(),
                false,
            ), // 2f2e
            Move::normal(
                parse_usi_square("6d").unwrap(),
                parse_usi_square("6e").unwrap(),
                false,
            ), // 6d6e
            Move::normal(
                parse_usi_square("2e").unwrap(),
                parse_usi_square("2d").unwrap(),
                false,
            ), // 2e2d (threatens capture)
        ];

        for mv in &moves {
            pos.do_move(*mv);
        }

        let history = Arc::new(History::new());
        let stack = SearchStack::default();
        let mut picker = MovePicker::new_quiescence(&pos, None, &history, &stack, 1);

        // Quiescence picker should only generate captures
        while let Some(mv) = picker.next_move() {
            if !mv.is_drop() {
                assert!(
                    pos.board.piece_on(mv.to()).is_some(),
                    "Quiescence picker generated non-capture move"
                );
            }
        }
    }

    #[test]
    fn test_history_influence_on_ordering() {
        let pos = Position::startpos();
        let mut history = History::new();
        let stack = SearchStack::default();

        // Update history for a specific move (5g5f)
        // In the starting position, this is a pawn move
        let good_move = Move::normal_with_piece(
            parse_usi_square("5g").unwrap(),
            parse_usi_square("5f").unwrap(),
            false,
            PieceType::Pawn,
            None,
        );
        history.update_cutoff(Color::Black, good_move, 10, None);

        let history_arc = Arc::new(history);
        let mut picker = MovePicker::new(&pos, None, None, &history_arc, &stack, 1);

        // Collect all quiet moves
        let mut quiet_moves = Vec::new();
        while let Some(mv) = picker.next_move() {
            if !mv.is_drop() && pos.board.piece_on(mv.to()).is_none() {
                quiet_moves.push(mv);
            }
        }

        // The good move should appear relatively early among quiet moves
        let good_move_position = quiet_moves
            .iter()
            .position(|&mv| mv == good_move)
            .expect("Good move should be generated");

        assert!(
            good_move_position < quiet_moves.len() / 2,
            "Good move with high history score should be ordered early"
        );
    }

    #[test]
    fn test_search_performance_with_move_picker() {
        let evaluator = Arc::new(MaterialEvaluator);
        let mut searcher = EnhancedSearcher::new(64, evaluator);
        let mut pos = Position::startpos();

        // Time-limited search
        let start = std::time::Instant::now();
        let (_, _) = searcher.search(&mut pos, 8, Some(Duration::from_millis(100)), None);
        let elapsed = start.elapsed();

        assert!(elapsed < Duration::from_millis(150), "Search took too long: {elapsed:?}");
    }
}

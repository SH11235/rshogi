# 置換表（Transposition Table）パフォーマンスサマリー

## 現在の実装状況

### アーキテクチャ
- **動的バケットサイジング**: Small(4)、Medium(8)、Large(16)エントリ構成を実装
- **SIMD最適化**: 並列キー検索のためのAVX2およびSSE2実装
- **自動サイズ選択**: テーブルサイズに基づく選択（≤8MB: Small、9-32MB: Medium、>32MB: Large）

## パフォーマンスベンチマーク

### バケットサイズ比較
| バケットサイズ | エントリ数 | メモリ | プローブ時間 | 用途 |
|------------|---------|--------|------------|----------|
| Small | 4 | 64B (1キャッシュライン) | 9.91 ns | キャッシュ効率重視（≤8MBテーブル） |
| Medium | 8 | 128B (2キャッシュライン) | 11.42 ns | バランス型（9-32MBテーブル） |
| Large | 16 | 256B (4キャッシュライン) | ~12-13 ns | 容量重視（>32MBテーブル） |

### SIMD vs スカラー性能（8エントリバケット）
| 操作 | スカラー | SIMD (SSE2修正前) | SIMD (SSE2修正後) | 優位 |
|-----------|--------|---------|---------|--------|
| ヒット（早期） | 4.77 ns | 6.23 ns | 6.23 ns | スカラー |
| ヒット（中間） | 5.26 ns | 6.20 ns | 6.21 ns | スカラー |
| ヒット（最後） | 5.71 ns | 6.20 ns | 7.01 ns | スカラー |
| ミス | 5.78 ns | 6.20 ns | 6.23 ns | スカラー |

**注**: SSE2のバグ修正により正確性は向上したが、パフォーマンスへの改善は見られない。むしろ最後のエントリのヒットで若干の性能低下が見られる。

### 主要な発見
1. **SIMDオーバーヘッド**: アトミックメモリ操作が性能を支配し、SIMDの利点を制限
2. **早期終了の優位性**: スカラーはマッチ時に早期終了可能、SIMDは全エントリを処理する必要がある
3. **キャッシュ効率**: 4エントリバケットは単一キャッシュラインに収まり、最良のレイテンシを提供
4. **SSE2実装の課題**: バグ修正後も性能向上せず、正確なマスク判定のオーバーヘッドが追加

## 技術詳細

### メモリレイアウト
- 各エントリ: 16バイト（8バイトキー + 8バイトデータ）
- アトミック操作: 読み込みに`Ordering::Acquire`、書き込みに`Ordering::Release`を使用
- アライメント: バケットはサイズ境界にアライン

### SIMD実装
- **4エントリ**: 単一AVX2 256ビットレジスタまたは2x SSE2 128ビットレジスタ
- **8エントリ**: 2x AVX2 256ビットレジスタ、前半マッチ時の早期終了付き
- **16エントリ**: 将来のAVX-512サポート準備済み

## 将来の最適化機会

1. **メモリバリア最適化**: relaxedオーダリング + フェンスでアトミック操作のオーバーヘッドを削減
2. **プリフェッチ戦略**: シーケンシャルアクセスパターンのキャッシュヒット率向上
3. **ハイブリッドアプローチ**: 最初の数エントリはスカラー、残りはSIMDで処理

## メモリバリア最適化の試み（2025年8月）

### 実装内容
- **probe_scalar**: すべてのキーを最初にRelaxedでロード、マッチ時に1回だけAcquireフェンス
- **FlexibleTTBucket**: probe_scalar_4/8/16を同様に最適化
- **find_worst_entry_scalar**: バッチロードパターンを適用

### ベンチマーク結果

#### プローブ操作のパフォーマンス変化
| テーブルサイズ | アクセスパターン | 時間 (ns) | 変化率 |
|--------------|---------------|-----------|---------|
| 1MB | mixed_access | 13.549 | -1.53% ✓ |
| 1MB | mostly_hits | 15.597 | +1.04% |
| 1MB | all_misses | 11.447 | -0.36% |
| 8MB | mixed_access | 16.433 | **+9.37%** ✗ |
| 8MB | mostly_hits | 15.651 | +1.87% ✗ |
| 8MB | all_misses | 12.922 | +1.72% ✗ |
| 32MB | mixed_access | 26.520 | **+28.74%** ✗ |
| 32MB | mostly_hits | 20.176 | **+9.20%** ✗ |
| 32MB | all_misses | 16.735 | **+12.72%** ✗ |
| 128MB | mixed_access | 37.996 | **+13.66%** ✗ |
| 128MB | mostly_hits | 29.502 | **+12.35%** ✗ |
| 128MB | all_misses | 25.281 | **+15.10%** ✗ |

#### バケットサイズ別パフォーマンス（最適化後）
| バケットサイズ | エントリ数 | 時間 (ns) | 備考 |
|--------------|---------|-----------|------|
| Small | 4 | 16.310 | 1キャッシュライン |
| Medium | 8 | 47.156 | 2キャッシュライン、大幅な劣化 |
| Large | 16 | 127.18 | 4キャッシュライン、さらに劣化 |

#### 4エントリキー検索パフォーマンス（最適化後）
| 操作 | スカラー (ns) | SIMD (ns) | 変化率(スカラー) | 変化率(SIMD) | 優位 |
|------|-------------|-----------|----------------|--------------|------|
| ヒット（位置0） | 2.004 | 2.652 | +0.52% | +1.27% | スカラー |
| ヒット（位置2） | 3.018 | 3.301 | +0.53% | **+1.73%** | スカラー |
| ヒット（位置3） | 4.251 | 3.653 | +0.32% | +1.00% | SIMD |
| ミス | 3.298 | 2.509 | +1.09% | +0.73% | SIMD |

#### 8エントリバケットの詳細パフォーマンス（最適化後）
| 操作 | スカラー (ns) | SIMD (ns) | 変化率(スカラー) | 変化率(SIMD) | 優位 |
|------|-------------|-----------|----------------|--------------|------|
| ヒット（最初） | 4.755 | 6.226 | -0.32% | -0.88% | スカラー |
| ヒット（中間） | 5.279 | 6.247 | +0.79% | +0.62% | スカラー |
| ヒット（最後） | 5.772 | 7.021 | +0.40% | +0.11% | スカラー |
| ミス | 5.759 | 6.258 | +0.65% | +0.10% | スカラー |

**優先度計算パフォーマンス（4エントリ）**
| ケース | スカラー (ns) | SIMD (ns) | 変化率(スカラー) | 変化率(SIMD) | 優位 |
|--------|-------------|-----------|----------------|--------------|------|
| 典型的 | 3.732 | 5.280 | **-3.10%** ✓ | +1.25% | スカラー |
| 深い探索 | 3.709 | 5.292 | **+7.52%** ✗ | **+5.80%** ✗ | スカラー |
| 浅い探索 | 3.734 | 5.293 | **+8.07%** ✗ | **+5.61%** ✗ | スカラー |

**優先度計算パフォーマンス（8エントリ）**
| 実装 | 時間 (ns) | 変化率 | 備考 |
|------|-----------|--------|------|
| スカラー | 5.311 | +0.56% | ほぼ変化なし |
| SIMD | 5.121 | **+5.49%** ✗ | 顕著な劣化 |

**バルク処理パフォーマンス**
| 操作 | 実装 | 時間 | 変化率 | 備考 |
|------|------|------|--------|------|
| 検索（1000件） | スカラー | 3.667 µs | **+8.91%** ✗ | 大幅劣化 |
| 検索（1000件） | SIMD | 4.487 µs | **-6.08%** ✓ | 改善 |
| 処理（100件） | スカラー | 305.12 ns | +0.90% | 軽微な劣化 |
| 処理（100件） | SIMD | 288.27 ns | +1.88% | SIMDの方が高速だが劣化 |

### 分析と問題点

1. **予期しない性能劣化**: 
   - 小さいテーブル（1MB）では若干の改善または変化なし
   - 大きいテーブル（8MB以上）では顕著な性能劣化（最大28%）
   - バケットサイズが大きいほど劣化が激しい

2. **推定される原因**:
   - **メモリアクセスパターンの悪化**: 全キーの事前ロードが追加のキャッシュミスを引き起こしている可能性
   - **早期終了の喪失**: 最初のエントリでマッチしても全キーをロードするオーバーヘッド
   - **メモリ帯域幅の圧迫**: 大きいバケットで不要なデータの読み込みが増加
   - **CPUパイプラインの非効率化**: 投機的実行の妨げになっている可能性

3. **最適化の再検討が必要**:
   - 現在のアプローチは理論的には正しいが、実際のハードウェアでは逆効果
   - 早期終了を維持しながらメモリバリアを削減する別の手法の検討が必要
   - ハイブリッドアプローチ（最初の2エントリはスカラー、残りはSIMD）の方が有望かもしれない

4. **詳細ベンチマークの知見**:
   - **4エントリ検索**: スカラーは微小な変化、SIMDは若干劣化（最大+1.73%）
   - **優先度計算の混在結果**: 
     - 典型的ケースでスカラーが-3.10%改善（唯一の改善点）
     - 深い/浅い探索では両実装とも5-8%劣化
   - **バルク処理の逆転現象**:
     - スカラー: +8.91%の大幅劣化（バッチロードの悪影響）
     - SIMD: -6.08%の改善（唯一の明確な改善）
   - **依然としてスカラー優位**: 単一操作ではスカラーが優位、バルク処理のみSIMDが有効

## 結論

現在の実装は、置換表管理のための柔軟で拡張可能なアーキテクチャを提供している。メモリバウンドな操作のため、現在のベンチマークではSIMD最適化の利点は限定的だが、このインフラストラクチャは将来の最適化と、SIMDがより効果的になる可能性のある大規模バケットサイズをサポートしている。

**2025年8月のメモリバリア最適化の試みは、予想に反して性能劣化を引き起こした。** これは、メモリアクセスパターンの最適化が単純なメモリバリア削減よりも重要であることを示唆している。

### 最適化の成果と失敗の総括

**唯一の改善点**:
- スカラー優先度計算（典型的ケース）: -3.10%
- SIMDバルク検索（1000件）: -6.08%

**主要な劣化**:
- 大規模テーブル（32MB以上）: +9%～+28%の大幅劣化
- スカラーバルク検索: +8.91%の劣化
- 優先度計算（深い/浅い探索）: +5%～+8%の劣化

**結論**: 早期終了の価値がメモリバリア削減の利益を大きく上回ることが実証された。この最適化は**ロールバックを強く推奨**する。

## ハイブリッドアプローチによる改善（2025年8月）

### 実装内容
前回の失敗を踏まえ、**早期終了を復活させつつ単一メモリフェンスを維持**するハイブリッドアプローチを実装：

```rust
// ハイブリッド実装：早期終了 + 単一フェンス
for i in 0..BUCKET_SIZE {
    let key = self.entries[i * 2].load(Ordering::Relaxed);
    if key == target_key {
        matching_idx = Some(i);
        break; // 早期終了を復活！
    }
}
if let Some(idx) = matching_idx {
    std::sync::atomic::fence(Ordering::Acquire); // 単一フェンス維持
    // データ読み込み
}
```

### ベンチマーク結果（ハイブリッド実装）

#### メモリバリアベンチマーク
| テーブルサイズ | アクセスパターン | 変化率 | 評価 |
|--------------|---------------|---------|------|
| 1MB | mostly_hits | **-1.52%** | ✅ 改善 |
| 8MB | mixed_access | +1.55% | ⚠️ 軽微な劣化 |
| 32MB | mixed_access | +10.86% | ⚠️ 前回(+28.74%)より大幅改善 |
| 32MB | mostly_hits | +5.66% | ⚠️ 前回(+9.20%)より改善 |
| 128MB | mixed_access | -0.67% | ✅ 前回(+13.66%)から改善 |
| **バケットサイズ** | | | |
| 8エントリ | - | **-1.43%** | ✅ 改善 |
| 16エントリ | - | **-60.29%** | ✅ 大幅改善！ |
| single_thread (100回) | - | **-10.45%** | ✅ 大幅改善 |

#### 8エントリ詳細ベンチマーク（全面的改善）
| 操作 | スカラー改善率 | SIMD改善率 | 評価 |
|------|--------------|-----------|------|
| ヒット（最初） | **-5.35%** | **-4.53%** | ✅ |
| ヒット（中間） | **-6.11%** | **-5.95%** | ✅ |
| ヒット（最後） | **-6.21%** | **-5.47%** | ✅ |
| ミス | **-5.89%** | **-5.20%** | ✅ |
| 優先度計算 | **-6.30%** | **-10.50%** | ✅ |
| バルク処理 | **-6.84%** | **-6.67%** | ✅ |

#### 優先度計算パフォーマンス（4エントリ）
| ケース | スカラー改善率 | SIMD改善率 | 評価 |
|--------|--------------|-----------|------|
| 典型的 | **-6.39%** | **-9.39%** | ✅ |
| 深い探索 | **-5.85%** | **-7.89%** | ✅ |
| 浅い探索 | **-7.42%** | **-7.83%** | ✅ |

### 成功要因の分析

1. **早期終了の復活が決定的**
   - 最初のエントリでヒット時：1回のキーロードのみ（前回は4-16回）
   - 平均的なケース：2-3回のキーロード（前回は全キーロード）
   - メモリアクセスの大幅削減

2. **単一メモリフェンスの維持**
   - マッチ後に1回のみAcquireフェンス（元実装は8回）
   - メモリバリアオーバーヘッドの最小化

3. **キャッシュ効率の改善**
   - 不要なメモリロードを回避
   - キャッシュラインの有効活用
   - メモリ帯域幅の節約

### 最終評価

**ハイブリッドアプローチは大成功：**
- ✅ 8エントリ構成で全面的に5-10%改善
- ✅ 16エントリバケットで60%の驚異的改善
- ✅ 前回の問題（大規模テーブルでの大幅劣化）を軽減
- ✅ 実使用パターンで安定した改善

**教訓：**
- 理論的に正しい最適化（メモリバリア削減）でも、実際のハードウェアでは逆効果になることがある
- 早期終了によるメモリアクセス削減の価値は、メモリバリア削減の利益を大きく上回る
- ハイブリッドアプローチ（早期終了＋単一フェンス）が最適解

この最適化により、置換表のプローブ操作が大幅に高速化され、特に実使用で一般的な8エントリ構成において顕著な性能向上を達成した。
# 将棋エンジン時間管理モジュール実装計画

## 概要

本ドキュメントは、rust-core将棋エンジンに実装する時間管理モジュール（`time_management`）の詳細な実装計画を示します。レビューフィードバックを反映し、実装上の詳細仕様と段階的な開発計画を定義します。

## 1. 要件定義

### 1.1 時間制御モード

| モード | 説明 | 実装優先度 |
|-------|------|-----------|
| **Fischer** | 残り時間＋増分 (`remain + inc`) | 高 |
| **FixedTime** | 1手あたり固定時間 | 高 |
| **FixedNodes** | 指定ノード数で停止 | 中 |
| **Byoyomi** | 基本時間＋秒読み（期管理あり） | 中 |
| **Infinite** | ユーザー停止まで探索 | 低 |
| **Ponder** | 相手番思考（ponderhitで即停止） | 高 |

> **用語統一**: "Fixed time per move"、"MoveTime" → **FixedTime**に統一

### 1.2 時間割り当てポリシー

#### Move-over-Move方式
```
base_time = (remain_ms / moves_left) + increment_ms * 0.8
```

#### 局面係数
- **開始局面（Opening）**: 1.2倍
- **中盤（MiddleGame）**: 1.0倍
- **終盤（EndGame）**: 0.8倍

#### 動的オーバーヘッド
```rust
dynamic_overhead = max(50, rtt_estimate / 2)  // ネットワーク遅延対応
```

### 1.3 検索停止条件

1. **ハードリミット到達**: `elapsed >= hard_limit`（必ず停止）
2. **ソフトリミット＋PV安定**: `elapsed >= soft_limit && pv_stable`
3. **ノードリミット**: `nodes >= node_limit`（FixedNodesモード）
4. **ユーザー/GUI信号**: `force_stop()` / `ponderhit`
5. **緊急停止**: 時間切迫時の安全フェイル

### 1.4 緊急停止条件（時間制御種別ごと）

| 時間制御 | 緊急停止条件 |
|---------|-----------|
| Fischer | `remain_ms < 300 && increment_ms == 0` |
| Byoyomi（基本時間） | `main_remain_ms < 300` |
| Byoyomi（秒読み） | `remain_in_period_ms < 80` |
| FixedTime | `elapsed > hard_limit * 1.1` |
| その他 | なし |

### 1.5 技術要件

- **チェック周期**: 15ms または 2048ノードごと（早い方）
- **スレッド安全性**: エンジンごとに1インスタンス、ロックレス設計
- **Atomic Ordering**:
  - 書き込み: `Relaxed`
  - 読み取り: `Acquire`（メモリ可視性保証）
- **Instant管理**: `parking_lot::Mutex<Instant>`使用（AtomicU64変換によるUB回避）

## 2. API設計

### 2.1 コア構造体

```rust
// src/time_management/mod.rs
use parking_lot::Mutex;
use std::sync::{
    atomic::{AtomicBool, AtomicU64, Ordering},
    Arc,
};
use std::time::{Duration, Instant};

/// 時間管理の中核
pub struct TimeManager {
    inner: Arc<TimeManagerInner>,
}

/// 時間制御設定
#[derive(Debug, Clone)]
pub enum TimeControl {
    /// Fischer制御: 基本時間＋増分
    Fischer { 
        white_ms: u64, 
        black_ms: u64, 
        increment_ms: u64 
    },
    /// 固定時間/手
    FixedTime { 
        ms_per_move: u64 
    },
    /// 固定ノード数
    FixedNodes { 
        nodes: u64 
    },
    /// 秒読み（日本式）
    /// 
    /// 注：このenumは初期設定のみを保持する。
    /// 実際の残り期数などのランタイム状態はTimeManager内部の
    /// ByoyomiStateで別途管理される。
    Byoyomi { 
        main_time_ms: u64,      // 基本持ち時間（初期値）
        byoyomi_ms: u64,        // 1期あたりの秒読み時間
        periods: u32,           // 秒読み期数（初期値）
    },
    /// 無限思考
    Infinite,
    /// 先読み（相手番思考）
    Ponder,
}

/// 検索制限パラメータ
#[derive(Debug, Clone)]
pub struct SearchLimits {
    pub time_control: TimeControl,
    pub moves_to_go: Option<u32>,    // 次の時間制御までの手数
    pub depth: Option<u32>,          // 最大深さ
    pub nodes: Option<u64>,          // 最大ノード数
}

/// 内部状態（スレッド間共有）
struct TimeManagerInner {
    // === 初期化後不変 ===
    time_control: TimeControl,
    side_to_move: Color,
    start_ply: u32,
    
    // === 可変状態（Atomic/Mutex） ===
    // 時刻管理（Mutex使用）
    start_time: Mutex<Instant>,
    
    // 制限値（Atomic）
    soft_limit_ms: AtomicU64,
    hard_limit_ms: AtomicU64,
    overhead_ms: AtomicU64,
    
    // 検索状態
    nodes_searched: AtomicU64,
    stop_flag: AtomicBool,
    
    // PV安定性追跡
    last_pv_change_ms: AtomicU64,     // 開始からの経過ミリ秒
    pv_threshold_ms: AtomicU64,       // 安定判定閾値
    
    // Byoyomi専用状態
    byoyomi_state: Mutex<ByoyomiState>,
}

/// 秒読み状態管理
/// 
/// TimeControl::Byoyomiとは別に、実際のランタイム状態を追跡する。
/// これにより設定（immutable）と状態（mutable）を明確に分離。
#[derive(Debug, Clone)]
struct ByoyomiState {
    periods_left: u32,      // 残り期数
    current_period_ms: u64, // 現在期の残り時間
    in_byoyomi: bool,       // 基本時間を使い切って秒読みに入ったか
}
```

### 2.2 公開API

```rust
impl TimeManager {
    /// 新規時間管理インスタンス作成
    pub fn new(
        limits: &SearchLimits, 
        side: Color, 
        ply: u32, 
        game_phase: GamePhase
    ) -> Self;
    
    /// 検索停止判定（検索ループから高頻度呼び出し）
    pub fn should_stop(&self, current_nodes: u64) -> bool;
    
    /// PV変更通知（安定性ベース時間延長用）
    pub fn on_pv_change(&self, depth: u32);
    
    /// 強制停止（ユーザー割り込み）
    pub fn force_stop(&self);
    
    /// 経過時間取得
    pub fn elapsed_ms(&self) -> u64;
    
    /// 手番終了後の時間更新
    /// 
    /// Byoyomiの場合、期の消費を管理：
    /// - time_spent_ms > byoyomi_ms の場合、1期消費
    /// - 全期消費で時間切れフラグ設定
    /// 
    /// 注：TimeControl設定は変更されず、内部のByoyomiStateのみ更新
    pub fn finish_move(&self, color: Color, time_spent_ms: u64);
    
    /// 秒読み状態取得（GUI向けAPI）
    /// 
    /// 返り値: Some((periods_left, current_period_ms, in_byoyomi)) または None
    pub fn get_byoyomi_state(&self) -> Option<(u32, u64, bool)>;
    
    /// 現在の時間情報取得（USI/ログ用）
    pub fn get_time_info(&self) -> TimeInfo;
    
    /// Ponderヒット処理
    pub fn ponder_hit(&self);
}

/// 時間情報（読み取り専用）
#[derive(Debug, Clone)]
pub struct TimeInfo {
    pub elapsed_ms: u64,
    pub soft_limit_ms: u64,
    pub hard_limit_ms: u64,
    pub nodes_searched: u64,
    pub time_pressure: f32,      // 0.0=余裕あり、1.0=切迫
    pub byoyomi_info: Option<ByoyomiInfo>,
}

/// 秒読み情報（TimeInfo経由で公開）
/// 
/// TimeManager内部のByoyomiStateから生成される読み取り専用の情報。
/// GUIなどへの状態通知に使用。
#[derive(Debug, Clone)]
pub struct ByoyomiInfo {
    pub in_byoyomi: bool,       // 秒読み中かどうか
    pub periods_left: u32,      // 残り期数
    pub current_period_ms: u64, // 現在期の残り時間
}
```

### 2.3 TimeManager初期化

```rust
impl TimeManager {
    pub fn new(limits: &SearchLimits, side: Color, ply: u32, game_phase: GamePhase) -> Self {
        // ... パラメータ取得と時間割り当て計算 ...
        
        // 秒読み状態の初期化
        let byoyomi_state = match &limits.time_control {
            TimeControl::Byoyomi { periods, byoyomi_ms, main_time_ms } => {
                ByoyomiState {
                    periods_left: *periods,
                    current_period_ms: *byoyomi_ms,
                    in_byoyomi: *main_time_ms == 0,  // 基本時間0なら即秒読み開始
                }
            }
            _ => ByoyomiState::default(),
        };
        
        // ... TimeManagerInner作成 ...
    }
}
```

## 3. アルゴリズム詳細

### 3.1 時間割り当て計算

```rust
fn calculate_time_allocation(
    time_control: &TimeControl,
    side: Color,
    ply: u32,
    moves_to_go: Option<u32>,
    game_phase: GamePhase,
    params: &TimeParameters,
) -> (u64, u64) {  // (soft_limit_ms, hard_limit_ms)
    match time_control {
        TimeControl::Fischer { white_ms, black_ms, increment_ms } => {
            let remain_ms = if side == Color::White { *white_ms } else { *black_ms };
            
            // 安全フェイル：残り時間不足
            if remain_ms < params.critical_fischer_ms && *increment_ms == 0 {
                return (50, 100);  // 最小時間で即座に手を返す
            }
            
            let moves_left = moves_to_go.unwrap_or_else(|| estimate_moves_remaining(ply));
            let base_ms = (remain_ms / moves_left as u64) + (increment_ms * params.inc_usage as u64 / 10);
            
            // 局面係数適用
            let phase_factor = match game_phase {
                GamePhase::Opening => params.opening_factor,
                GamePhase::MiddleGame => 1.0,
                GamePhase::EndGame => params.endgame_factor,
            };
            
            let soft_ms = ((base_ms as f64) * phase_factor * params.soft_multiplier) as u64;
            let hard_ms = ((soft_ms as f64) * params.hard_multiplier) as u64
                .min(remain_ms * 8 / 10);
            
            let overhead = params.overhead_ms;
            (
                soft_ms.saturating_sub(overhead),
                hard_ms.saturating_sub(overhead),
            )
        }
        
        TimeControl::FixedTime { ms_per_move } => {
            let soft = ((*ms_per_move as f64) * 0.9) as u64;
            (soft, *ms_per_move)
        }
        
        TimeControl::Byoyomi { main_time_ms, byoyomi_ms, .. } => {
            // Byoyomi実装は3.4参照
            calculate_byoyomi_time(main_time_ms, byoyomi_ms, params)
        }
        
        TimeControl::FixedNodes { .. } => (u64::MAX, u64::MAX),
        TimeControl::Infinite => (u64::MAX, u64::MAX),
        TimeControl::Ponder => (u64::MAX, u64::MAX),
    }
}
```

### 3.2 残り手数推定

```rust
fn estimate_moves_remaining(ply: u32) -> u32 {
    const AVERAGE_GAME_LENGTH: u32 = 120;
    let moves_played = ply / 2;
    
    // 標準的なゲーム進行曲線に基づく推定
    if moves_played < 30 {
        60  // 序盤は長めに見積もる
    } else if moves_played < 80 {
        40  // 中盤
    } else {
        20  // 終盤は最低20手を確保
    }
}
```

### 3.3 PV安定性による動的調整

```rust
impl TimeManager {
    pub fn on_pv_change(&self, depth: u32) {
        let now_ms = self.elapsed_ms();
        self.inner.last_pv_change_ms.store(now_ms, Ordering::Relaxed);
        
        // 深さに応じた閾値調整
        let params = self.get_params();
        let threshold = params.pv_base_threshold_ms + 
                       (depth as u64 * params.pv_depth_slope_ms);
        self.inner.pv_threshold_ms.store(threshold, Ordering::Relaxed);
    }
    
    fn is_pv_stable(&self) -> bool {
        let now_ms = self.elapsed_ms();
        let last_change = self.inner.last_pv_change_ms.load(Ordering::Acquire);
        let threshold = self.inner.pv_threshold_ms.load(Ordering::Acquire);
        
        now_ms.saturating_sub(last_change) > threshold
    }
}
```

### 3.4 秒読み（Byoyomi）実装

```rust
fn calculate_byoyomi_time(
    main_time_ms: u64,
    byoyomi_ms: u64,
    params: &TimeParameters,
) -> (u64, u64) {
    if main_time_ms > 0 {
        // まだ基本時間内 - Fischer同様に保守的割り当て
        // 基本時間の20%をソフトリミット、50%をハードリミットとして使用
        let soft = main_time_ms / 5;  // 20% = 1/5
        let hard = main_time_ms / 2;  // 50% = 1/2
        (soft, hard)
    } else {
        // 秒読み中 - 期内時間の80%をソフトリミットとして使用
        let soft = (byoyomi_ms * 4) / 5;  // 80% = 4/5
        let hard = byoyomi_ms;
        let overhead = params.overhead_ms;
        (soft.saturating_sub(overhead), hard.saturating_sub(overhead))
    }
}

impl TimeManager {
    pub fn finish_move(&self, color: Color, time_spent_ms: u64) {
        match &self.inner.time_control {
            TimeControl::Byoyomi { main_time_ms, byoyomi_ms, periods } => {
                let mut state = self.inner.byoyomi_state.lock();
                
                if !state.in_byoyomi {
                    // まだ基本時間内
                    // 注：実際の基本時間追跡はGUI側で管理
                    // ここでは基本時間を0になった場合の秒読み移行を処理
                    if *main_time_ms == 0 {
                        state.in_byoyomi = true;
                    }
                } else {
                    // 秒読み中
                    if time_spent_ms > *byoyomi_ms {
                        // 期を1つ消費
                        state.periods_left = state.periods_left.saturating_sub(1);
                        
                        if state.periods_left == 0 {
                            // 時間切れ - 強制停止フラグを立てる
                            self.inner.stop_flag.store(true, Ordering::Release);
                        } else {
                            // 次の期にリセット
                            state.current_period_ms = *byoyomi_ms;
                        }
                    } else {
                        // 期内に指した - 次の手で使える時間
                        state.current_period_ms = byoyomi_ms.saturating_sub(time_spent_ms);
                    }
                }
            }
            _ => {}
        }
    }
}
```

### 3.5 停止判定実装

```rust
impl TimeManager {
    pub fn should_stop(&self, current_nodes: u64) -> bool {
        // 強制停止フラグ（最も高速なチェック）
        if self.inner.stop_flag.load(Ordering::Acquire) {
            return true;
        }
        
        // ノード数更新（fetch_addで競合回避）
        let prev_nodes = self.inner.nodes_searched.fetch_add(
            current_nodes.saturating_sub(self.inner.nodes_searched.load(Ordering::Relaxed)),
            Ordering::Relaxed
        );
        
        // ノード制限チェック
        if let TimeControl::FixedNodes { nodes } = &self.inner.time_control {
            if current_nodes >= *nodes {
                return true;
            }
        }
        
        // 時間ベースのチェック
        let elapsed = self.elapsed_ms();
        
        // ハードリミット
        let hard_limit = self.inner.hard_limit_ms.load(Ordering::Acquire);
        if elapsed >= hard_limit {
            return true;
        }
        
        // ソフトリミット＋PV安定性
        let soft_limit = self.inner.soft_limit_ms.load(Ordering::Acquire);
        if elapsed >= soft_limit && self.is_pv_stable() {
            return true;
        }
        
        // 緊急停止チェック
        if self.is_time_critical() {
            return true;
        }
        
        false
    }
    
    fn is_time_critical(&self) -> bool {
        match &self.inner.time_control {
            TimeControl::Fischer { white_ms, black_ms, increment_ms } => {
                let remain = if self.inner.side_to_move == Color::White {
                    *white_ms
                } else {
                    *black_ms
                };
                remain < CRITICAL_FISCHER_MS && *increment_ms == 0
            }
            TimeControl::Byoyomi { .. } => {
                let state = self.inner.byoyomi_state.lock();
                // 秒読み中で期内時間が少ない場合に危険
                state.in_byoyomi && state.current_period_ms < CRITICAL_BYOYOMI_MS
            }
            TimeControl::FixedTime { .. } => {
                // オーバーラン防止
                let elapsed = self.elapsed_ms();
                let hard = self.inner.hard_limit_ms.load(Ordering::Acquire);
                elapsed > hard * 11 / 10  // 110%超過
            }
            _ => false,
        }
    }
}
```

## 4. 既存コードへの統合

### 4.1 SearchContext修正

```rust
// search_enhanced.rs
pub struct SearchContext<'a> {
    // ... 既存フィールド ...
    pub time_manager: Option<TimeManager>,
}

impl<'a> SearchContext<'a> {
    fn should_stop(&self) -> bool {
        // 既存の停止フラグ
        if self.stop_flag.load(Ordering::Relaxed) {
            return true;
        }
        
        // 時間管理による停止判定
        if let Some(ref tm) = self.time_manager {
            if tm.should_stop(self.stats.nodes) {
                return true;
            }
        }
        
        // 既存のノード/深さチェック
        // ...
    }
}
```

### 4.2 アルファベータ探索への統合

```rust
fn alpha_beta<E: Evaluator>(
    ctx: &mut SearchContext,
    // ... パラメータ ...
) -> i32 {
    // ... 既存コード ...
    
    // PV更新時の通知
    if score > alpha && score < beta {
        // PVが変わった
        if let Some(ref tm) = ctx.time_manager {
            tm.on_pv_change(depth);
        }
        
        // ... トランスポジションテーブル更新など ...
    }
    
    // ... 残りの処理 ...
}
```

### 4.3 Engineコントローラ統合

```rust
// engine/controller.rs
impl Engine {
    pub fn search(&mut self, limits: SearchLimits) -> SearchResult {
        // ゲームフェーズ判定
        let game_phase = estimate_game_phase(&self.position);
        
        // 時間管理作成
        let time_manager = TimeManager::new(
            &limits,
            self.position.side_to_move(),
            self.position.game_ply(),
            game_phase,
        );
        
        // 検索コンテキスト作成
        let mut context = SearchContext::new(
            &self.position,
            self.transposition_table.as_mut(),
            Some(time_manager),
        );
        
        // 探索実行
        let result = search_enhanced(&mut context);
        
        // 時間消費を記録
        if let Some(tm) = context.time_manager {
            tm.finish_move(
                self.position.side_to_move(),
                tm.elapsed_ms(),
            );
        }
        
        result
    }
}
```

## 5. テスト戦略

### 5.1 単体テスト（MockClock使用）

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use instant::MockClock;
    
    #[test]
    fn test_fischer_time_allocation() {
        MockClock::set_time(0);
        
        let limits = SearchLimits {
            time_control: TimeControl::Fischer {
                white_ms: 60000,
                black_ms: 60000,
                increment_ms: 1000,
            },
            ..Default::default()
        };
        
        let tm = TimeManager::new(&limits, Color::White, 0, GamePhase::Opening);
        let info = tm.get_time_info();
        
        // 開始局面は1.2倍の時間
        assert!(info.soft_limit_ms > 1200);
        assert!(info.hard_limit_ms > info.soft_limit_ms);
        assert!(info.hard_limit_ms <= 48000); // 60秒の80%
    }
    
    #[test]
    fn test_byoyomi_period_consumption() {
        MockClock::set_time(0);
        
        let limits = SearchLimits {
            time_control: TimeControl::Byoyomi {
                main_time_ms: 0,  // 既に秒読み
                byoyomi_ms: 30000,
                periods: 3,
            },
            ..Default::default()
        };
        
        let tm = TimeManager::new(&limits, Color::Black, 80, GamePhase::EndGame);
        
        // 35秒消費（期オーバー）
        tm.finish_move(Color::Black, 35000);
        
        let info = tm.get_time_info();
        assert_eq!(info.byoyomi_info.unwrap().periods_left, 2);
    }
    
    #[test]
    fn test_pv_stability_with_depth() {
        MockClock::set_time(0);
        let tm = create_test_manager();
        
        // 深さ10でPV変更
        tm.on_pv_change(10);
        MockClock::advance(50);
        assert!(!tm.is_pv_stable()); // 50ms < 80+10*5=130ms
        
        MockClock::advance(100);
        assert!(tm.is_pv_stable());  // 150ms > 130ms
    }
}
```

### 5.2 並行性テスト（loom使用）

```rust
#[cfg(loom)]
#[test]
fn test_concurrent_stop_check() {
    use loom::thread;
    
    loom::model(|| {
        let tm = Arc::new(create_test_manager());
        let tm1 = tm.clone();
        let tm2 = tm.clone();
        
        let t1 = thread::spawn(move || {
            for i in 0..1000 {
                tm1.should_stop(i);
            }
        });
        
        let t2 = thread::spawn(move || {
            thread::yield_now();
            tm2.force_stop();
        });
        
        t1.join().unwrap();
        t2.join().unwrap();
        
        assert!(tm.should_stop(0));
    });
}
```

### 5.3 統合テスト

```rust
#[test]
fn test_search_respects_time_limit() {
    let mut engine = Engine::new();
    let position = Position::from_sfen(INITIAL_SFEN).unwrap();
    engine.set_position(position);
    
    let limits = SearchLimits {
        time_control: TimeControl::FixedTime { ms_per_move: 1000 },
        ..Default::default()
    };
    
    let start = Instant::now();
    let result = engine.search(limits);
    let elapsed = start.elapsed();
    
    // 時間制限を守っているか
    assert!(elapsed.as_millis() <= 1100); // 100msのバッファ
    assert!(result.best_move.is_some());
    assert!(result.pv.len() > 0);
}
```

### 5.4 ベンチマークテスト

```rust
// benches/time_management.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_should_stop(c: &mut Criterion) {
    let tm = create_bench_time_manager();
    
    c.bench_function("should_stop", |b| {
        let mut nodes = 0u64;
        b.iter(|| {
            nodes += 1;
            black_box(tm.should_stop(nodes))
        });
    });
}

fn benchmark_time_allocation(c: &mut Criterion) {
    c.bench_function("calculate_allocation_fischer", |b| {
        b.iter(|| {
            calculate_time_allocation(
                &TimeControl::Fischer {
                    white_ms: 300000,
                    black_ms: 300000,
                    increment_ms: 5000,
                },
                Color::White,
                40,
                None,
                GamePhase::MiddleGame,
                &TimeParameters::default(),
            )
        });
    });
}

criterion_group!(benches, benchmark_should_stop, benchmark_time_allocation);
criterion_main!(benches);
```

## 6. チューニングパラメータ

```rust
/// 時間管理の調整可能パラメータ
#[derive(Debug, Clone, serde::Deserialize)]
pub struct TimeParameters {
    // オーバーヘッド
    pub overhead_ms: u64,              // デフォルト: 50
    pub network_overhead_factor: f64,   // デフォルト: 0.5
    
    // PV安定性
    pub pv_base_threshold_ms: u64,     // デフォルト: 80
    pub pv_depth_slope_ms: u64,        // デフォルト: 5
    
    // 緊急停止閾値
    pub critical_fischer_ms: u64,      // デフォルト: 300
    pub critical_byoyomi_ms: u64,      // デフォルト: 80
    
    // 時間配分係数
    pub soft_multiplier: f64,          // デフォルト: 1.0
    pub hard_multiplier: f64,          // デフォルト: 4.0
    pub increment_usage: f64,          // デフォルト: 0.8
    
    // 局面係数
    pub opening_factor: f64,           // デフォルト: 1.2
    pub endgame_factor: f64,           // デフォルト: 0.8
}

impl Default for TimeParameters {
    fn default() -> Self {
        Self {
            overhead_ms: 50,
            network_overhead_factor: 0.5,
            pv_base_threshold_ms: 80,
            pv_depth_slope_ms: 5,
            critical_fischer_ms: 300,
            critical_byoyomi_ms: 80,
            soft_multiplier: 1.0,
            hard_multiplier: 4.0,
            increment_usage: 0.8,
            opening_factor: 1.2,
            endgame_factor: 0.8,
        }
    }
}
```

## 7. 実装フェーズ

### Phase 1: 基礎実装（第1週）
- [ ] `time_management`モジュール作成
- [ ] `TimeManager`、`TimeControl`、`SearchLimits`実装
- [ ] Fischer/FixedTime時間割り当てアルゴリズム
- [ ] 基本的な単体テスト（MockClock使用）

### Phase 2: 検索統合（第2週）
- [ ] `SearchContext`へのTimeManager統合
- [ ] `should_stop()`の時間ベース判定追加
- [ ] PV変更追跡とon_pv_change実装
- [ ] loomによる並行性テスト

### Phase 3: 高度な機能（第3週）
- [ ] Byoyomi期管理実装
- [ ] Ponder機能とponderhit処理
- [ ] 緊急時間管理と安全フェイル
- [ ] WASM環境でのテスト

### Phase 4: 最適化とチューニング（第4週）
- [ ] ベンチマークテストと性能最適化
- [ ] 自己対局によるパラメータチューニング
- [ ] ドキュメント完成
- [ ] リリース準備

## 8. リスクと対策

| リスク | 対策 |
|-------|------|
| WASM環境でのタイマー精度不足 | `performance.now()`使用、フォールバックでノードベース停止 |
| Instant→AtomicU64変換のUB | `parking_lot::Mutex<Instant>`で安全に管理 |
| 並行アクセスによる競合状態 | 適切なAtomic Ordering（write:Relaxed, read:Acquire） |
| 秒読み期0での時間切れ | 強制停止＋最善手即座返却の実装 |
| ネットワーク遅延の影響 | 動的オーバーヘッド調整機能 |

## 9. パフォーマンス目標

- 時間割り当て計算: < 0.1ms/回
- should_stop()呼び出し: < 0.01ms/回
- メモリ使用量: < 1KB/TimeManagerインスタンス
- ホットパスでのメモリアロケーション: 0
- 検索中のミューテックスロック: 0（ロックフリー設計）

## 10. 将来の拡張

1. **機械学習統合**: ゲームデータベースから時間配分パターンを学習
2. **局面複雑度分析**: 複雑な局面により多くの時間を配分
3. **対戦相手モデリング**: 相手の時間管理パターンに基づく調整
4. **Multi-PV時間管理**: 複数の主要変化に時間を分配
5. **クラスタ探索**: 分散環境での総時間管理

---

本実装計画は、プロフェッショナルグレードの時間管理システムを段階的に構築し、既存のコードベースとシームレスに統合することを目的としています。各フェーズでの明確な成果物とテスト戦略により、高品質な実装を保証します。

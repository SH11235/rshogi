# ABDADA (Alpha-Beta Distributed Duplicate Avoidance) 実装

## 概要

ABDADAは、ベータカットオフが発生した局面をマークすることで、スレッド間の重複作業を削減する並列探索最適化技術です。この実装では、置換表に軽量なフラグを追加し、兄弟スレッドに対してその局面が既にカットオフを生成したことを通知します。

## 実装詳細

### TTビットレイアウト

ABDADAフラグはTTエントリの予約ビットのbit 0を使用します：
- **Bit 0**: `ABDADA_CUT_FLAG` - ベータカットオフ発生時に設定
- **Bit 1**: 将来の使用のために予約

### 主要コンポーネント

1. **フラグ操作** (`tt.rs`)
   - `set_exact_cut()`: アトミックCAS操作でABDADAフラグを設定
   - `has_exact_cut()`: フラグが設定されているかチェック
   - `clear_exact_cut()`: フラグをクリア（メンテナンス用）

2. **探索統合** (`node.rs`)
   - TTプローブ後の早期カットオフチェック（depth > 2）
   - ベータカットオフ時のフラグ設定
   - 古いエントリを回避するための深さ検証

### メモリオーダリング

- **書き込み側**: フラグ設定時にReleaseオーダリングを使用
- **読み込み側**: フラグチェック時にAcquireオーダリングを使用
- スレッド間の適切な同期を保証

### 設計上の決定事項

1. **無限リトライループ**: CAS操作は`spin_loop()`ヒントを使用して無限にリトライします。これは以下の理由で許容されます：
   - 正確なハッシュ一致時のみ発生（稀）
   - クリティカルセクションが最小限（単一ビット更新）
   - `spin_loop()`が競合時にOSスケジューラに譲歩

2. **深さガード**: 浅いエントリが深い探索を誤って打ち切ることを防ぐため、早期リターンには`entry.depth() >= depth - 1`が必要です。

3. **Depth > 2 閾値**: 重複のコストが低い浅い探索でのオーバーヘッドを避けるため、ABDADAはdepth > 2でのみ有効です。

## パフォーマンスへの影響

期待される効果：
- 重複探索作業の削減（マルチスレッドNPSで5-10%の改善）
- スレッド数に応じたより良いスケーリング
- シングルスレッド探索での最小限のオーバーヘッド

## 使用方法

ABDADA最適化は以下の条件で並列探索時に自動的に有効になります：
- 複数スレッドが探索中
- 置換表が有効
- 探索深さ > 2

設定は不要です - この最適化はユーザーに対して透過的です。
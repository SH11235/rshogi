# Transposition Table CAS最適化の記録

## 概要

2025年8月、Transposition Table（TT）のCAS（Compare-And-Swap）オーバーヘッドを削減する最適化を実施。Write-Through戦略を試みたが、最終的にシンプルなCAS実装に論理バグ修正と最小限の最適化を加えた実装に落ち着いた。

## 背景

Phase 4ベンチマークでTTのCASオーバーヘッドが26-82%の性能低下を引き起こしていることが判明。特に：
- 単一スレッドでもメモリフェンスのコストが顕在化
- 全ての書き込みでCASを使用していた
- 70.7%が既存エントリの更新（CAS不要な可能性）

## 実施内容と結果

### Phase 1: 計測基盤とPrefetch無効化
- **結果**: +6.1%改善（予想を上回る）
- **発見**: CAS失敗率0%、70.7%が既存エントリ更新

### Phase 2: Write-Through戦略
- **実装**: 既存エントリ更新でCAS回避
- **結果**: -2.3%性能低下（期待に反して）
- **原因**: 2回のReleaseストアがCAS1回より重い

### Phase 2.1: Acquire/Release最適化
- **実装**: Acquireをdata側に移動、key再書き込み削除
- **結果**: -3.7%（さらに悪化）
- **発見**: 論理バグ - 空スロット挿入時にReaderが不整合を観測可能

### Phase 1'（最終実装）
- **論理バグ修正**: data→key順序を保証
- **最適化**:
  - 既存エントリ: CAS不要、1ストア（70.7%）
  - 空スロット: 2ストア（29.3%）
- **結果**:
  - ストア数: 66.7%削減
  - CAS使用: 70.7%削減
  - 性能: -3.3%（正しさ優先）

## 重要な学び

1. **正しさが最優先** - 性能のためにデータ整合性を犠牲にしてはいけない
2. **測定の重要性** - 理論と実装の乖離が明確になった（ストア削減≠性能向上）
3. **シンプルさの価値** - 複雑な最適化より、正しくシンプルな実装が重要
4. **CASの効率性** - 適切に使用すれば、CASは十分効率的

## 技術的詳細

### 論理バグの内容
```rust
// バグのある実装（mainブランチ）
match compare_exchange_weak(0, new_key, ...) {
    Ok(_) => {
        // CAS後にdataを書く
        store(data);  // Readerが新keyと古dataを見る可能性
    }
}

// 修正後
store(data);  // 先にdataを書く
match compare_exchange_weak(0, new_key, ...) {
    Ok(_) => {
        // CASのReleaseがdataを可視化
    }
}
```

### 最終的な最適化
```rust
if old_key == target_key {
    // 既存エントリ: CAS不要
    store(data, Release);
    return;
} else if old_key == 0 {
    // 空スロット: 2ストア
    store(data, Relaxed);
    compare_exchange_weak(0, new_key, Release, Relaxed);
}
```

## 今後の方向性

1. **Phase 3: 置換戦略の最適化**
   - depth比較による更新フィルタ
   - 書き込み総量の削減

2. **実探索ベンチマーク導入**
   - 実際の競合パターン測定
   - より現実的な評価

## まとめ

CAS最適化の試みは、理論と実装の複雑な相互作用を示した。最終的に、論理的正しさを保ちつつ、可能な範囲での最適化を実現。-3.3%の性能劣化は、データ整合性を保証するための必要なコストである。

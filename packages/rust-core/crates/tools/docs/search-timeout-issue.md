# 探索タイムアウト問題の分析

**更新**: 2025-07-31

## 修正状況

### 実施した修正
1. `search_basic.rs` の `alpha_beta` ループで毎手 `should_stop()` をチェック
2. `quiesce` ループでも毎手チェック
3. `bump_nodes_and_check()` で10ノードごとにチェック

### 結果
- 部分的に改善されたが、完全には解決していない
- 一部の局面では依然として探索が完了しない
- タイムアウトメッセージは表示されるが、処理が進まない

### 根本原因の推測
1. **探索の再帰的な性質**: 深い探索で累積的な遅延が発生
2. **Rayonの同期待機**: `par_iter().map().collect()` がすべての結果を待つ
3. **特定の局面での探索爆発**: 問題の局面で探索木が異常に大きくなる可能性

## 推奨される回避策

### 短期的解決策: `generate_training_data_safe` を使用

```bash
./target/release/generate_training_data_safe input.txt output.txt 50
```

このバージョンは：
- 各局面を別スレッドで実行
- チャネルベースのタイムアウト（確実に動作）
- 深さ3で安定動作

### 中長期的解決策

1. **探索アルゴリズムの再設計**
   - ノンブロッキング探索の実装
   - より細かい粒度でのチェックポイント

2. **並列処理方式の変更**
   - `tokio` などの非同期ランタイムの使用
   - タスクベースの並列処理

3. **探索制限の強化**
   - ノード数制限の追加
   - 時間ベースの強制終了

## 問題の概要

`generate_training_data` ツールで特定の局面を処理する際に、探索が無限ループまたはデッドロックに陥り、`stop_flag` によるタイムアウトが効かない問題が発生しています。

## 問題の局面

以下の局面（バッチ6の3番目、全体で53番目）で確実に再現します：

```
sfen l1s1k2nl/1r1g2g2/p2pppspp/2p3p2/1p1n5/2PS1PPP1/PP1PP1N1P/2GK2SR1/LN3G2L w Bb 24
```

## 症状

1. `SearchLimits` で `fixed_time_ms(500)` と `stop_flag` を設定しているにも関わらず、探索が終了しない
2. CPUの使用率が1コアのみ100%になり、他のコアはアイドル状態
3. 数分待っても処理が完了しない（理論上は500ms以内に完了すべき）

## 検証結果

### 1. 並列処理自体は正常に動作
- 20コアが利用可能で、Rayonが正しく並列処理を行っている
- 各バッチの最初の局面は異なるスレッドで処理されている

### 2. タイムアウト機構の問題
- `stop_flag` を450ms後に `true` に設定しているが、探索が停止しない
- 問題の局面以外では、タイムアウトが正しく機能している

### 3. 回避策の成功
- `generate_training_data_safe` では、各局面を別スレッドで実行し、チャネル経由でタイムアウトを実装
- この方法では問題なく処理が完了する

## 原因の推測

1. **探索ループ内での `stop_flag` チェック頻度が不十分**
   - 特定の局面では、探索の内部ループが長時間実行され、`stop_flag` のチェックに到達しない

2. **特定の局面での探索木の爆発**
   - 問題の局面は24手目で、駒が複雑に配置されており、合法手が多い可能性
   - 探索木が急激に広がり、チェックポイントに到達するまでに時間がかかる

3. **アトミック変数の読み取り最適化**
   - コンパイラが `stop_flag` の読み取りを最適化し、ループ外に移動している可能性

## 修正方針

1. **探索の主要ループで `stop_flag` を確実にチェック**
   - alpha-beta探索の各ノードで確認
   - 合法手生成ループ内でも定期的に確認

2. **Ordering の明示的な指定**
   - `Ordering::Acquire` を使用して、最新の値を確実に読み取る

3. **ノード数カウンタによる強制終了**
   - 一定のノード数を超えたら強制的に探索を終了

## テストケース

問題の局面を使用して、修正前後で以下を確認：

1. 500ms以内に探索が終了すること
2. `stop_flag` が正しく機能すること
3. 評価値が妥当な範囲内であること

## 次のステップ

1. エンジンの探索コード（`engine-core/src/search/`）を調査
2. `stop_flag` のチェック箇所を特定し、不足している箇所に追加
3. 問題の局面でテストして修正を確認
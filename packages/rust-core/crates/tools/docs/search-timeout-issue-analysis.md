# 探索タイムアウト問題の詳細分析

## 分析結果

### 1. 問題の局面は正常
- 合法手生成: 79手（正常）
- 深さ3までの探索: 336,475ノード（約14ms）
- 局面自体に異常なし

### 2. 問題の原因
探索コードの `should_stop()` チェックが不十分：

#### 現在のチェック箇所
1. `alpha_beta()` の各移動手の処理前（324行目）
2. `quiesce()` の開始時（375行目）
3. `search()` のイテレーティブディープニング各深さ完了後（238行目）

#### 問題点
- **合法手生成ループ内でチェックなし**: 79手すべてを生成してからチェック
- **ノード数ベースのチェック頻度が低い**: `bump_nodes_and_check()` は呼ばれるが、頻度が不十分
- **深い探索での累積遅延**: 深さ4で各ノードが少しずつ遅れると累積する

### 3. 具体的な問題シナリオ
深さ4の探索で：
1. 各ノードで79手を生成（チェックなし）
2. 79手すべてを探索開始（最初の手の前にのみチェック）
3. タイムアウト後も残りの78手を処理継続
4. 探索木が深くなるにつれて累積

### 4. 修正方針

#### A. 即時対応（should_stopチェックの追加）
1. 合法手生成後、一定数ごとにチェック
2. alpha-beta内のループで頻繁にチェック
3. quiesce内でもより頻繁にチェック

#### B. 根本対応（ノード数ベースの制限）
1. ノード数カウンタを頻繁に確認
2. 一定ノード数（例：1000ノード）ごとに強制チェック

## 実装案

```rust
// alpha_beta内での改善例
for (move_idx, &mv) in moves.as_slice().iter().enumerate() {
    // 10手ごとにチェック
    if move_idx > 0 && move_idx % 10 == 0 && self.should_stop() {
        return SEARCH_INTERRUPTED;
    }
    
    // 既存の処理...
}
```

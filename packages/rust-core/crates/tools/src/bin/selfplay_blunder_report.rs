use anyhow::{Context, Result};
use chrono::Local;
use clap::Parser;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::{Path, PathBuf};

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about = "Detect large evaluation drops in selfplay logs and emit blunder reports + targets.json"
)]
struct Cli {
    /// Input JSONL logs generated by selfplay_basic
    #[arg(required = true)]
    inputs: Vec<PathBuf>,

    /// Drop threshold in centipawns (negative delta <= -threshold is reported)
    #[arg(long, default_value_t = 300)]
    threshold: i32,

    /// Optional limit on number of blunders to keep (largest |delta| first)
    #[arg(long)]
    top: Option<usize>,

    /// Directory to write report files (defaults to runs/analysis/<logstem>-blunders)
    #[arg(long)]
    out: Option<PathBuf>,

    /// Maximum number of info log lines to attach per blunder
    #[arg(long, default_value_t = 20)]
    max_info_lines: usize,

    /// Centipawn equivalent used when encountering mate scores
    #[arg(long, default_value_t = 100_000)]
    mate_cp: i32,

    /// Minimum number of plies to look back from the detected spike
    #[arg(long, default_value_t = 0)]
    back_min: u32,

    /// Maximum number of plies to look back from the detected spike
    #[arg(long, default_value_t = 3)]
    back_max: u32,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
struct MainEvalLog {
    #[serde(default)]
    score_cp: Option<i32>,
    #[serde(default)]
    score_mate: Option<i32>,
    #[serde(default)]
    depth: Option<u32>,
    #[serde(default)]
    seldepth: Option<u32>,
    #[serde(default)]
    nodes: Option<u64>,
    #[serde(default)]
    time_ms: Option<u64>,
    #[serde(default)]
    nps: Option<u64>,
    #[serde(default)]
    pv: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct MoveRecord {
    game_id: u32,
    ply: u32,
    #[serde(default)]
    side_to_move: Option<char>,
    sfen_before: String,
    move_usi: String,
    engine: String,
    #[serde(default)]
    main_eval: Option<MainEvalLog>,
    #[serde(default)]
    result: Option<String>,
}

#[derive(Debug, Deserialize)]
struct MetaEntry {
    #[serde(default)]
    timestamp: Option<String>,
    #[serde(default)]
    engine_names: Option<EngineNames>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct EngineNames {
    black: String,
    white: String,
}

#[derive(Debug, Deserialize)]
struct InfoLogEntry {
    #[serde(default)]
    kind: Option<String>,
    #[serde(default)]
    game_id: Option<u32>,
    #[serde(default)]
    ply: Option<u32>,
    #[serde(default)]
    engine: Option<String>,
    #[serde(default)]
    line: Option<String>,
}

#[derive(Clone, Default)]
struct GameEvalState {
    last_cp: Option<i32>,
    last_eval: Option<MainEvalLog>,
    history: Vec<String>,
}

impl GameEvalState {
    fn record_position(&mut self, sfen: &str) {
        self.history.push(sfen.to_string());
    }

    fn position_for_back(&self, ply: u32, back: u32) -> Option<String> {
        if ply == 0 {
            return None;
        }
        if back >= ply {
            return None;
        }
        let idx = (ply - back - 1) as usize;
        self.history.get(idx).map(|s| format!("sfen {}", s))
    }
}

#[derive(Serialize)]
struct BlunderEntry {
    log_path: String,
    info_log_path: Option<String>,
    game_id: u32,
    ply: u32,
    move_usi: String,
    side_to_move: Option<char>,
    sfen_before: String,
    pre_position: String,
    tag: String,
    eval_before_cp: Option<i32>,
    eval_after_cp: Option<i32>,
    delta_cp: i32,
    eval_before: Option<MainEvalLog>,
    eval_after: Option<MainEvalLog>,
    result: Option<String>,
    info_lines: Vec<String>,
    log_timestamp: Option<String>,
    engine_names: Option<EngineNames>,
    back_plies: u32,
}

#[derive(Serialize)]
struct TargetEntry {
    tag: String,
    pre_position: String,
    origin_log: String,
    origin_game: u32,
    origin_ply: u32,
    origin_delta_cp: i32,
    back_plies: u32,
}

#[derive(Serialize)]
struct TargetsFile {
    targets: Vec<TargetEntry>,
}

struct DetectionConfig {
    threshold: i32,
    mate_cp: i32,
    max_info_lines: usize,
    back_min: u32,
    back_max: u32,
}

#[derive(Serialize)]
struct Summary {
    threshold: i32,
    total_inputs: usize,
    total_blunders: usize,
    unique_targets: usize,
    generated_at: String,
}

#[derive(Serialize)]
struct BlunderReport {
    summary: Summary,
    blunders: Vec<BlunderEntry>,
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    anyhow::ensure!(
        cli.back_max >= cli.back_min,
        "--back-max must be greater than or equal to --back-min"
    );
    let timestamp = Local::now().format("%Y%m%d-%H%M%S").to_string();
    let default_dir = derive_default_out(&cli.inputs, &timestamp);
    let out_dir = cli.out.clone().unwrap_or(default_dir);
    std::fs::create_dir_all(&out_dir)?;
    let detect_cfg = DetectionConfig {
        threshold: cli.threshold,
        mate_cp: cli.mate_cp,
        max_info_lines: cli.max_info_lines,
        back_min: cli.back_min,
        back_max: cli.back_max,
    };

    let mut all_blunders: Vec<BlunderEntry> = Vec::new();
    let mut target_index: HashMap<String, usize> = HashMap::new();
    let mut targets: Vec<TargetEntry> = Vec::new();
    let mut seen_games: HashSet<(PathBuf, u32)> = HashSet::new();

    for input in &cli.inputs {
        let info_path = derive_info_path(input);
        let info_map = load_info_map(&info_path).unwrap_or_default();
        let mut state = LogState {
            meta: None,
            game_states: HashMap::new(),
            blunders: Vec::new(),
        };
        state.process_log(input, &info_map, &detect_cfg)?;
        for game_id in state.game_states.keys() {
            seen_games.insert((input.clone(), *game_id));
        }

        for mut entry in state.blunders {
            entry.log_path = input.display().to_string();
            entry.info_log_path =
                info_path.as_ref().filter(|p| p.exists()).map(|p| p.display().to_string());
            entry.log_timestamp = state.meta.as_ref().and_then(|m| m.timestamp.clone());
            entry.engine_names = state.meta.as_ref().and_then(|m| m.engine_names.clone());

            let target_tag = assign_target(&entry, &mut target_index, &mut targets, input);
            entry.tag = target_tag;
            all_blunders.push(entry);
        }
    }

    if let Some(limit) = cli.top {
        all_blunders.sort_by_key(|b| std::cmp::Reverse(b.delta_cp.abs()));
        all_blunders.truncate(limit);
        let (new_targets, new_index) = rebuild_targets(&mut all_blunders);
        targets = new_targets;
        target_index = new_index;
    }

    let summary = Summary {
        threshold: cli.threshold,
        total_inputs: cli.inputs.len(),
        total_blunders: all_blunders.len(),
        unique_targets: targets.len(),
        generated_at: timestamp.clone(),
    };

    let report = BlunderReport {
        summary,
        blunders: all_blunders,
    };

    let blunders_json = out_dir.join("blunders.json");
    let mut writer = BufWriter::new(File::create(&blunders_json)?);
    serde_json::to_writer_pretty(&mut writer, &report)?;
    writer.flush()?;

    let targets_json = out_dir.join("targets.json");
    let mut targets_writer = BufWriter::new(File::create(&targets_json)?);
    serde_json::to_writer_pretty(&mut targets_writer, &TargetsFile { targets })?;
    targets_writer.flush()?;

    let summary_txt = out_dir.join("summary.txt");
    let mut summary_writer = BufWriter::new(File::create(&summary_txt)?);
    writeln!(
        summary_writer,
        "inputs={}",
        cli.inputs
            .iter()
            .map(|p| p.display().to_string())
            .collect::<Vec<_>>()
            .join(", ")
    )?;
    writeln!(
        summary_writer,
        "threshold={} mate_cp={} max_info_lines={}",
        cli.threshold, cli.mate_cp, cli.max_info_lines
    )?;
    writeln!(summary_writer, "blunders={}", report.blunders.len())?;
    writeln!(summary_writer, "targets={}", target_index.len())?;
    writeln!(summary_writer, "generated_at={timestamp}")?;
    summary_writer.flush()?;

    println!("wrote report to {}", blunders_json.display());
    println!("wrote targets to {}", targets_json.display());
    println!("summary -> {}", summary_txt.display());

    println!("unique games touched: {}", seen_games.len());
    Ok(())
}

fn derive_info_path(input: &Path) -> Option<PathBuf> {
    let mut path = input.to_path_buf();
    if let Some(ext) = path.extension() {
        if ext == "jsonl" {
            path.set_extension("info.jsonl");
            return Some(path);
        }
    }
    None
}

fn derive_default_out(inputs: &[PathBuf], _timestamp: &str) -> PathBuf {
    let stem = inputs
        .first()
        .and_then(|p| p.file_stem())
        .and_then(|s| s.to_str())
        .map(|s| s.to_string())
        .unwrap_or_else(|| "blunders".to_string());
    let sanitized = stem.replace(['/', '\\'], "-");
    PathBuf::from(format!("runs/analysis/{sanitized}-blunders"))
}

fn assign_target(
    entry: &BlunderEntry,
    index: &mut HashMap<String, usize>,
    targets: &mut Vec<TargetEntry>,
    input: &Path,
) -> String {
    if let Some(idx) = index.get(&entry.pre_position) {
        return targets[*idx].tag.clone();
    }
    let stem = input.file_stem().and_then(|s| s.to_str()).unwrap_or("log");
    let tag = format!("{stem}-g{}-ply{}", entry.game_id, entry.ply);
    let new_index = targets.len();
    targets.push(TargetEntry {
        tag: tag.clone(),
        pre_position: entry.pre_position.clone(),
        origin_log: entry.log_path.clone(),
        origin_game: entry.game_id,
        origin_ply: entry.ply,
        origin_delta_cp: entry.delta_cp,
        back_plies: entry.back_plies,
    });
    index.insert(entry.pre_position.clone(), new_index);
    tag
}

fn rebuild_targets(blunders: &mut [BlunderEntry]) -> (Vec<TargetEntry>, HashMap<String, usize>) {
    let mut targets: Vec<TargetEntry> = Vec::new();
    let mut index: HashMap<String, usize> = HashMap::new();
    for entry in blunders.iter_mut() {
        if let Some(idx) = index.get(&entry.pre_position) {
            entry.tag = targets[*idx].tag.clone();
            continue;
        }
        let stem = Path::new(&entry.log_path).file_stem().and_then(|s| s.to_str()).unwrap_or("log");
        let tag = format!("{stem}-g{}-ply{}", entry.game_id, entry.ply);
        let position = entry.pre_position.clone();
        index.insert(position.clone(), targets.len());
        targets.push(TargetEntry {
            tag: tag.clone(),
            pre_position: position,
            origin_log: entry.log_path.clone(),
            origin_game: entry.game_id,
            origin_ply: entry.ply,
            origin_delta_cp: entry.delta_cp,
            back_plies: entry.back_plies,
        });
        entry.tag = tag;
    }
    (targets, index)
}

fn load_info_map(path: &Option<PathBuf>) -> Result<HashMap<(u32, u32), Vec<String>>> {
    let info_path = match path {
        Some(p) => p,
        None => return Ok(HashMap::new()),
    };
    if !info_path.exists() {
        return Ok(HashMap::new());
    }
    let file = File::open(info_path)
        .with_context(|| format!("failed to open info log {}", info_path.display()))?;
    let reader = BufReader::new(file);
    let mut map: HashMap<(u32, u32), Vec<String>> = HashMap::new();
    for line in reader.lines() {
        let line = line?;
        if line.trim().is_empty() {
            continue;
        }
        let entry: InfoLogEntry = match serde_json::from_str(&line) {
            Ok(v) => v,
            Err(_) => continue,
        };
        if entry.kind.as_deref() != Some("info") {
            continue;
        }
        if entry.engine.as_deref() != Some("main") {
            continue;
        }
        let game_id = match entry.game_id {
            Some(g) => g,
            None => continue,
        };
        let ply = match entry.ply {
            Some(p) => p,
            None => continue,
        };
        let text = match entry.line {
            Some(t) => t,
            None => continue,
        };
        map.entry((game_id, ply)).or_default().push(text);
    }
    Ok(map)
}

struct LogState {
    meta: Option<MetaEntry>,
    game_states: HashMap<u32, GameEvalState>,
    blunders: Vec<BlunderEntry>,
}

impl LogState {
    fn process_log(
        &mut self,
        path: &Path,
        info_map: &HashMap<(u32, u32), Vec<String>>,
        cfg: &DetectionConfig,
    ) -> Result<()> {
        let file =
            File::open(path).with_context(|| format!("failed to open log {}", path.display()))?;
        let reader = BufReader::new(file);
        let stem = path.file_stem().and_then(|s| s.to_str()).unwrap_or("log");
        for line in reader.lines() {
            let line = line?;
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            let value: Value = serde_json::from_str(trimmed)
                .with_context(|| format!("failed to parse JSON in {}", path.display()))?;
            if value.get("type").and_then(|v| v.as_str()) == Some("meta") {
                self.meta = Some(serde_json::from_value(value)?);
                continue;
            }
            let record: MoveRecord = serde_json::from_value(value)?;
            if record.engine != "main" {
                continue;
            }
            let eval_snapshot = record.main_eval.clone();
            let eval_cp = eval_snapshot.as_ref().and_then(|e| eval_to_cp(e, cfg.mate_cp));
            let state = self.game_states.entry(record.game_id).or_default();
            state.record_position(&record.sfen_before);
            if let (Some(prev_cp), Some(cur_cp)) = (state.last_cp, eval_cp) {
                let delta = cur_cp - prev_cp;
                if delta <= -cfg.threshold {
                    let info_lines = info_map
                        .get(&(record.game_id, record.ply))
                        .map(|vec| vec.iter().take(cfg.max_info_lines).cloned().collect::<Vec<_>>())
                        .unwrap_or_default();
                    for back in cfg.back_min..=cfg.back_max {
                        if let Some(pre_position) = state.position_for_back(record.ply, back) {
                            let tag = format!(
                                "{stem}-g{}-ply{}-back{}",
                                record.game_id, record.ply, back
                            );
                            self.blunders.push(BlunderEntry {
                                log_path: String::new(),
                                info_log_path: None,
                                game_id: record.game_id,
                                ply: record.ply,
                                move_usi: record.move_usi.clone(),
                                side_to_move: record.side_to_move,
                                sfen_before: record.sfen_before.clone(),
                                pre_position,
                                tag,
                                eval_before_cp: state.last_cp,
                                eval_after_cp: eval_cp,
                                delta_cp: delta,
                                eval_before: state.last_eval.clone(),
                                eval_after: eval_snapshot.clone(),
                                result: record.result.clone(),
                                info_lines: info_lines.clone(),
                                log_timestamp: None,
                                engine_names: None,
                                back_plies: back,
                            });
                        }
                    }
                }
            }
            state.last_cp = eval_cp;
            state.last_eval = eval_snapshot;
        }
        Ok(())
    }
}

fn eval_to_cp(eval: &MainEvalLog, mate_cp: i32) -> Option<i32> {
    if let Some(cp) = eval.score_cp {
        Some(cp)
    } else if let Some(mate) = eval.score_mate {
        if mate > 0 {
            Some(mate_cp)
        } else if mate < 0 {
            Some(-mate_cp)
        } else {
            Some(0)
        }
    } else {
        None
    }
}

# ボードモジュールアーキテクチャ

この文書では、将棋盤実装のモジュール構成について説明します。

## モジュール概要

boardモジュールは、3,661行の単一ファイルから、整理された階層構造を持つ複数のモジュールにリファクタリングされました：

```
board/
├── attacks/        # 攻撃検出とピン計算
├── position/       # ゲーム局面と着手処理
├── see/           # 静的交換評価
├── bitboard.rs    # ビットボード操作 (204行)
├── board_repr.rs  # 盤面表現 (196行)
├── types.rs       # 基本型定義 (484行)
└── board.rs       # モジュールファサード (19行)
```

## モジュール詳細

### types.rs
ボード実装全体で使用される基本型を定義：
- `Square` - 盤面のマス表現 (0-80)
- `PieceType` - 駒の種類（王、飛車、角など）
- `Piece` - 色と成り状態を含む完全な駒情報
- `Color` - 手番（先手/後手）

### bitboard.rs
効率的な盤面操作のための`Bitboard`構造体を実装：
- 81マス用の128ビット表現
- 高速操作のためのビット演算
- 筋マスクの生成
- ビットカウントとビットスキャン

### board_repr.rs
ビットボードを使用した盤面状態の管理：
- 色と駒種別のビットボードを持つ`Board`構造体
- 駒の配置と除去
- パフォーマンス向上のための占有情報キャッシュ
- 王の位置検索

### position/
完全なゲーム局面管理（サブモジュールに分割）：
- `core.rs` - Position構造体と基本メソッド
- `moves.rs` - 着手の実行と取り消し
- `validation.rs` - 着手の検証とゲーム状態の照会

### attacks/
攻撃検出機能（サブモジュールに分割）：
- `non_sliding.rs` - 歩、桂、王、金、銀の攻撃
- `sliding.rs` - 飛車、角、香の攻撃
- `pins.rs` - ピン検出
- `core.rs` - 攻撃検出のメインAPI

### see/
駒の取り合い分析のための静的交換評価：
- `pin_info.rs` - SEE用の軽量ピン情報
- `helpers.rs` - 攻撃者検出と駒の価値
- `core.rs` - メインSEEアルゴリズム

## 設計原則

### 1. 単一責任の原則
各モジュールは明確に定義された目的を持ち、ボード実装の一側面を担当します。

### 2. 最小限の依存関係
モジュールは必要なものだけに依存し、結合度を低減します。

### 3. パフォーマンス重視
- 効率的な操作のためのビットボード
- 頻繁に使用される値のキャッシュ
- ホットパスでのインラインヒント

### 4. 型安全性
- `any`型の不使用
- 全体を通じた強い型付け
- 明示的なエラー処理

### 5. 後方互換性
メインの`board.rs`ファイルがすべてのパブリックアイテムを再エクスポートし、既存のAPIを維持します。

## 使用例

```rust
use engine_core::shogi::board::{Position, Move, Color};

// 開始局面を作成
let mut pos = Position::startpos();

// 着手を実行
let mv = Move::normal(Square::new(6, 6), Square::new(6, 5), false);
let undo_info = pos.do_move(mv);

// ゲーム状態を確認
if pos.is_in_check() {
    println!("王手です！");
}

// 着手を取り消し
pos.undo_move(mv, undo_info);
```

## パフォーマンスに関する考慮事項

### ビットボード操作
- 81マス盤用に128ビット整数を使用
- ビットカウント用のCPU命令を活用
- 非スライド駒用の事前計算された攻撃テーブル

### キャッシュ戦略
- `occupied_bb`は色別のすべての駒をキャッシュ
- `all_bb`は盤上のすべての駒をキャッシュ
- 攻撃テーブルは起動時に事前計算

### メモリレイアウト
- 駒のビットボード：2色 × 8駒種 = 16ビットボード
- コンパクトな表現によりキャッシュミスを最小化
- 高速な駒検索のためのマス配列

## 今後の改善

1. **SIMD最適化** - 並列ビットボード操作のためのSIMD命令の使用
2. **攻撃テーブルの圧縮** - 事前計算テーブルのメモリフットプリントの削減
3. **遅延評価** - 高コストな値を必要時のみ計算
4. **並列着手生成** - 異なる駒種の着手を並列に生成
# Desktop app release workflow with PGO optimization
name: Release Desktop

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 0.1.0)'
        required: true
        type: string
      draft:
        description: 'Create as draft release'
        required: false
        default: true
        type: boolean
      skip_pgo:
        description: 'Skip PGO optimization (faster build)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  SCCACHE_GHA_ENABLED: "true"

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact_suffix: linux-x86_64
            cpu_target: x86-64-v3
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            artifact_suffix: windows-x86_64
            cpu_target: x86-64-v3
          - platform: macos-latest
            target: aarch64-apple-darwin
            artifact_suffix: macos-arm64
            cpu_target: apple-m1

    runs-on: ${{ matrix.platform }}
    # PGOビルドは2回ビルドするため90分、skip_pgo時は45分
    timeout-minutes: ${{ inputs.skip_pgo == true && 45 || 90 }}

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Resolve versions
        id: versions
        shell: bash
        run: |
          NODE_VERSION=$(node -p "require('./package.json').volta.node" 2>/dev/null || echo "")
          if [ -z "$NODE_VERSION" ]; then
            echo "Error: Failed to resolve node version from package.json"
            exit 1
          fi
          echo "node=$NODE_VERSION" >> "$GITHUB_OUTPUT"

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ steps.versions.outputs.node }}
          cache: 'pnpm'

      - name: Install system dependencies (Linux)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            pkg-config \
            build-essential

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
          targets: ${{ matrix.target }}

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Enable sccache
        shell: bash
        run: echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV

      - name: Cache Rust
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            packages/rust-core -> target
            apps/desktop/src-tauri -> target
          cache-on-failure: true
          shared-key: "rust-desktop-${{ matrix.platform }}"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # =======================================================================
      # PGO (Profile-Guided Optimization) ビルド
      # =======================================================================
      #
      # PGOとは:
      #   コンパイラが「実際の実行パターン」を元に最適化を行う手法。
      #   通常のビルドでは静的な解析のみだが、PGOでは実行時の情報を活用する。
      #
      # 処理フロー:
      #   Step 1: profile-generate
      #     - 計装（instrumentation）コードを埋め込んだバイナリをビルド
      #     - このバイナリは実行時に「どの分岐を通ったか」等を記録する
      #
      #   Step 2: プロファイル収集
      #     - 計装バイナリでベンチマークを実行
      #     - 探索・NNUE評価など本番相当の処理を実行し、実行パターンを収集
      #     - 結果は .profraw ファイルに保存される
      #
      #   Step 3: プロファイルマージ
      #     - 複数の .profraw を統合して .profdata を生成
      #
      #   Step 4: profile-use
      #     - プロファイル情報を使って最適化ビルド
      #     - ホットパス（頻繁に実行されるコード）を連続メモリに配置
      #     - 分岐予測ヒントを挿入
      #     - 頻繁に呼ばれる関数を積極的にインライン化
      #
      # 効果:
      #   - NNUE評価: +6〜7% NPS向上
      #   - Material評価: +14% NPS向上
      #
      # =======================================================================

      # Set up PGO directory (cross-platform)
      - name: Setup PGO directory
        shell: bash
        run: |
          PGO_DIR="${RUNNER_TEMP}/pgo-data"
          mkdir -p "$PGO_DIR"
          echo "PGO_DIR=$PGO_DIR" >> $GITHUB_ENV

      # PGO Step 1: Build with profile generation
      - name: PGO - Build for profiling
        if: inputs.skip_pgo != true
        shell: bash
        working-directory: packages/rust-core
        run: |
          echo "=== PGO Step 1: Profile Generation Build ==="

          # Disable sccache for PGO (incompatible with profile instrumentation)
          unset RUSTC_WRAPPER

          RUSTFLAGS="-C target-cpu=${{ matrix.cpu_target }} -C profile-generate=${{ env.PGO_DIR }}" \
            cargo build --profile production

      # PGO Step 2: Run benchmark to collect profile
      - name: PGO - Collect profile data
        if: inputs.skip_pgo != true
        shell: bash
        working-directory: packages/rust-core
        run: |
          echo "=== PGO Step 2: Collecting Profile Data ==="

          # ベンチマーク実行（ログを保存しつつ出力）
          if ! ./target/production/benchmark 2>&1 | tee "${{ env.PGO_DIR }}/benchmark.log" | head -30; then
            echo "::warning::Benchmark execution failed, checking for partial profile data"
          fi

          PROFRAW_COUNT=$(find "${{ env.PGO_DIR }}" -name "*.profraw" 2>/dev/null | wc -l)
          echo "Collected $PROFRAW_COUNT profile files"

          if [ "$PROFRAW_COUNT" -eq 0 ]; then
            echo "::warning::No profile data collected, continuing without PGO"
            echo "PGO_AVAILABLE=false" >> $GITHUB_ENV
          else
            echo "PGO_AVAILABLE=true" >> $GITHUB_ENV
          fi

      # PGO Step 3: Merge profiles
      - name: PGO - Merge profiles
        if: inputs.skip_pgo != true && env.PGO_AVAILABLE == 'true'
        shell: bash
        run: |
          echo "=== PGO Step 3: Merging Profiles ==="

          # Find llvm-profdata in Rust toolchain
          if [ "$RUNNER_OS" = "Windows" ]; then
            LLVM_PROFDATA=$(find "$USERPROFILE/.rustup" -name "llvm-profdata.exe" -type f 2>/dev/null | head -1)
          else
            LLVM_PROFDATA=$(find ~/.rustup -name "llvm-profdata" -type f -executable 2>/dev/null | head -1)
          fi

          if [ -z "$LLVM_PROFDATA" ]; then
            echo "llvm-profdata not found, trying system version..."
            LLVM_PROFDATA=$(which llvm-profdata 2>/dev/null || echo "")
          fi

          if [ -z "$LLVM_PROFDATA" ]; then
            echo "Warning: llvm-profdata not found, continuing without PGO"
            echo "PGO_AVAILABLE=false" >> $GITHUB_ENV
            exit 0
          fi

          echo "Using: $LLVM_PROFDATA"
          "$LLVM_PROFDATA" merge -o "${{ env.PGO_DIR }}/merged.profdata" "${{ env.PGO_DIR }}"/*.profraw

          ls -lh "${{ env.PGO_DIR }}/merged.profdata"
          echo "PGO_PROFILE=${{ env.PGO_DIR }}/merged.profdata" >> $GITHUB_ENV

      # Clean for final build
      - name: Clean for production build
        if: inputs.skip_pgo != true
        shell: bash
        working-directory: packages/rust-core
        run: cargo clean

      # Build Tauri app with PGO
      - name: Build Tauri App (with PGO)
        if: inputs.skip_pgo != true && env.PGO_AVAILABLE == 'true'
        shell: bash
        working-directory: apps/desktop
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          echo "=== Building Tauri with PGO ==="
          echo "CPU target: ${{ matrix.cpu_target }}"
          echo "PGO profile: ${{ env.PGO_PROFILE }}"

          # Set RUSTFLAGS for profile-use (sccache disabled for PGO)
          unset RUSTC_WRAPPER
          export RUSTFLAGS="-C target-cpu=${{ matrix.cpu_target }} -C profile-use=${{ env.PGO_PROFILE }}"

          pnpm tauri build --target ${{ matrix.target }}

      # Build Tauri app without PGO (fallback or skip_pgo)
      - name: Build Tauri App (without PGO)
        if: inputs.skip_pgo == true || env.PGO_AVAILABLE != 'true'
        shell: bash
        working-directory: apps/desktop
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          echo "=== Building Tauri without PGO ==="
          export RUSTFLAGS="-C target-cpu=${{ matrix.cpu_target }}"
          pnpm tauri build --target ${{ matrix.target }}

      - name: sccache stats
        if: always()
        shell: bash
        run: sccache --show-stats || true

      # Upload artifacts
      - name: Upload artifacts (Linux)
        if: matrix.platform == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.artifact_suffix }}
          path: |
            apps/desktop/src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb
            apps/desktop/src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage
          if-no-files-found: error

      - name: Upload artifacts (Windows)
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.artifact_suffix }}
          path: |
            apps/desktop/src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi
            apps/desktop/src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe
          if-no-files-found: error

      - name: Upload artifacts (macOS)
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.artifact_suffix }}
          path: |
            apps/desktop/src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg
          if-no-files-found: error

  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: find artifacts -type f

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.version }}
          name: Desktop v${{ inputs.version }}
          draft: ${{ inputs.draft }}
          generate_release_notes: true
          files: |
            artifacts/**/*.deb
            artifacts/**/*.AppImage
            artifacts/**/*.msi
            artifacts/**/*.exe
            artifacts/**/*.dmg
